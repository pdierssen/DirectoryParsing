package com.chatgptchaos.chatgptchaos.view;


import com.chatgptchaos.chatgptchaos.constants.FilePaths;
import com.chatgptchaos.chatgptchaos.constants.NumericalConst;
import com.chatgptchaos.chatgptchaos.constants.Visuals;
import com.chatgptchaos.chatgptchaos.control.arena.ArenaController;
import com.chatgptchaos.chatgptchaos.control.general.GUIController;
import com.chatgptchaos.chatgptchaos.interfaces.GUIView;
import com.chatgptchaos.chatgptchaos.model.CustomButton;
import com.chatgptchaos.chatgptchaos.model.arena.ArenaPosition;
import com.chatgptchaos.chatgptchaos.model.player.Character;
import javafx.beans.property.IntegerProperty;
import javafx.fxml.FXML;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.RadioButton;
import javafx.scene.image.ImageView;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.text.FontWeight;

import java.io.IOException;
import java.text.NumberFormat;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Die Klasse represerntiert das ArenaModel mit GUI Elementen
 */
public class ArenaGUI implements GUIView
{
    private ArenaController controller;
    @FXML
    private GridPane arenaField;
    @FXML
    private RadioButton moveRadio;
    @FXML
    private RadioButton attackRadio;
    @FXML
    private VBox alliesBox;
    @FXML
    private VBox enemiesBox;
    @FXML
    private Pane pane;

    private VBox arena;

    private HashMap<Character, ImageView> characterImageViewRelation = new HashMap<>();
    private ImageView lastHighLightedImage;

    /**
     * Konstruktor der ArenaGui
     * @param arenaController der zugehörige ArenaController
     * @precondition keine
     * @postcondition Eine Instanz des ArenaGui ist erstellt
     */
    public ArenaGUI (ArenaController arenaController)
    {
        try {
            this.arena = loadGUI(FilePaths.ARENAFXML);
            this.controller = arenaController;
            initialiseTeamBoxes(controller.getArena().getAllies(), controller.getArena().getEnemies());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Initialisiert die Basis Gui Elemente der Instanz
     * @precondition keine
     * @postcondition Basis Elemente der Instanz sind initialisiert
     */
    @Override
    public void initialize ()
    {
        //add buttons to grid
        int[] buttonsize = {Visuals.ARENA_BUTTON_SIZE, Visuals.ARENA_BUTTON_SIZE};
        addButtonsToGrid(buttonsize);
        moveRadio.setSelected(true);
    }

    /**
     * Highlited den Übergebenen Character in der CharacterBox
     * @param character der zu highlightende Character
     * @precondition Instanz muss initialisiert sein
     * @postcondition übergebene Character wird highgelighted
     */
    public void hightLightCharacterImage (Character character)
    {
        if (lastHighLightedImage != null) {
            lastHighLightedImage.setScaleX(NumericalConst.DOWNSCALE_OF_IMAGE);
            lastHighLightedImage.setScaleY(NumericalConst.DOWNSCALE_OF_IMAGE);
            lastHighLightedImage.setStyle(Visuals.STYLE_NO_STYLE);
        }
        characterImageViewRelation.get(character).setScaleX(NumericalConst.SCALE_OF_IMAGE);
        characterImageViewRelation.get(character).setScaleY(NumericalConst.SCALE_OF_IMAGE);
        characterImageViewRelation.get(character).setStyle(Visuals.STYLE_HIGHLIGHTED_CHARACTER);
        lastHighLightedImage = characterImageViewRelation.get(character);
    }

    /**
     * Fügt Custom Buttons zu dem Grid hinzu
     * @param buttonsize die Konfiguration der Größe der Buttons
     * @precondition keine
     * @postcondition Die Knöpfe sind der Arena Gui hinzugefügt
     */
    private void addButtonsToGrid (int[] buttonsize)
    {
        //Iterates over all of the GridPanes nodes
        for (int row = NumericalConst.ITERATIONSTART; row < arenaField.getRowCount(); row++) {
            for (int collumn = NumericalConst.ITERATIONSTART; collumn < arenaField.getColumnCount(); collumn++) {
                CustomButton customButton = new CustomButton(new Button(), FilePaths.ARENABUTTONBACKGORUND,
                        Visuals.STANDART_FONT, FontWeight.BOLD, GUIConstants.ARENA_FONT_SIZE, buttonsize);
                arenaField.add(customButton.getButtonRef(), row, collumn);
            }
        }
    }

    /**
     * Initialisiert die Teamboxes
     * @param allies verbündetes Team
     * @param enemies gegnerisches Team
     * @precondition keine
     * @postcondition Die Team Boxen stellen die Teams dar
     */
    private void initialiseTeamBoxes (List<Character> allies, List<Character> enemies)
    {
        alliesBox.setMinWidth(Visuals.TEAM_BOX_WIDTH);
        enemiesBox.setMinWidth(Visuals.TEAM_BOX_WIDTH);
        StackPane characterStack;
        for (Character allyCharacter : allies) {
            characterStack = createCharacterStack(allyCharacter);
            alliesBox.getChildren().add(characterStack);
        }

        for (Character enemyCharacter : enemies) {
            characterStack = createCharacterStack(enemyCharacter);
            enemiesBox.getChildren().add(characterStack);
        }

    }

    /**
     * Kreiert eine StackPane zur Darstellung des Characters
     * @param character der darzustellende Character
     * @return der kreierte StackPane
     * @precondition keine
     * @postcondition der kreierte StackPane
     */
    private StackPane createCharacterStack (Character character)
    {
        ImageView characterImage = new ImageView(character.getImage());
        characterImage.setPreserveRatio(true);
        characterImage.setOnMouseClicked(e ->
        {
            clickedCharacter(character);
        });
        characterImageViewRelation.put(character, characterImage);
        Label healthBar = createLabel(character, Visuals.STYLE_BACKGROUND_RED, character.getStatusValues().healthProperty());
        Label shieldBar = createLabel(character, Visuals.STYLE_BACKGROUND_GREY, character.getStatusValues().shieldProperty());
        Label manaBar = createLabel(character, Visuals.STYLE_BACKGROUND_BLUE,
                character.getStatusValues().manaProperty());
        StackPane characterStack = new StackPane();
        StackPane.setAlignment(healthBar, Pos.BOTTOM_CENTER);
        StackPane.setAlignment(shieldBar, Pos.TOP_CENTER);
        StackPane.setAlignment(manaBar, Pos.BOTTOM_LEFT);
        characterStack.getChildren().addAll(characterImage, healthBar, shieldBar, manaBar);
        return characterStack;
    }

    /**
     * Kreirt ein Label für den übergebenen Character mit dem Backgroundstyle und der IntegerProperty
     * @param character der Charcter für den das Label erstellt wird
     * @param backgroundStyle Hintergrundstil
     * @param property die Property die Abgebildet wird
     * @return das kreierte Label
     * @precondition keine
     * @postcondition das Kreierte Label ist zurückgegeben
     */
    private Label createLabel (Character character, String backgroundStyle, IntegerProperty property)
    {
        Label label = new Label();
        label.setStyle(backgroundStyle);
        label.textProperty().bindBidirectional(property, NumberFormat.getInstance());
        return label;
    }

    /**
     * Aktualisiert die darstellung der Charactere
     * @param map Informationen über die Darstellung der Charactere
     * @precondition ArenaGui muss initialisiert sein
     * @postcondition Darstellung ist aktualisiert
     */
    public void showCharacterPositions (HashMap<Character, ArenaPosition> map)
    {
        pane.getChildren().clear();
        ImageView characterImage;
        for (Map.Entry<Character, ArenaPosition> entry : map.entrySet()) {
            characterImage = new ImageView(entry.getKey().getImage());
            characterImage.setFitHeight(Visuals.CHARACTER_IMAGE_IN_GAME);
            characterImage.setFitWidth(Visuals.CHARACTER_IMAGE_IN_GAME);
            setImageViewOnArenaPosition(characterImage, entry.getValue());
            pane.getChildren().add(characterImage);
        }
    }

    /**
     * Bildet das gegebene ImageView an der Position ab
     * @param image das abzubildene Image
     * @param position die Position des Images
     * @precondition keine
     * @postcondition Image ist abgebildet
     */
    private void setImageViewOnArenaPosition (ImageView image, ArenaPosition position)
    {
        boolean positionCriterium;
        for (Node node : arenaField.getChildren()) {
            if (node != null & node instanceof Button) {
                positionCriterium = (position.getColumnPosition() == GridPane.getColumnIndex(node) &
                        (position.getRowPosition() == GridPane.getRowIndex(node)));
                if (positionCriterium) {
                    image.setX(node.getLayoutX() + Visuals.ARENA_CHARACTER_IMAGE_OFFSET_X);
                    image.setY(node.getLayoutY());
                }
            }
        }
    }

    /**
     * Übergibt den geclickten Character dem Controller
     * @param character der Character der dem Controller übergeben werden soll
     * @precondition keine
     * @postcondition Charcter wird dem Controller übergeben
     */
    private void clickedCharacter (Character character)
    {
        controller.clickedCharacter(character);
    }

    /**
     * Zeigt die Gui an
     * @precondition der GuiController muss initialisiert sein
     * @postcondition die ArenaGUI wird angezeigt
     */
    @Override
    public void showGUI ()
    {
        GUIController.getInstance().setNewRoot(arena);
    }

    public GridPane getArenaField ()
    {
        return arenaField;
    }

    public RadioButton getMoveRadio ()
    {
        return moveRadio;
    }

    public RadioButton getAttackRadio ()
    {
        return attackRadio;
    }

    public VBox getAlliesBox ()
    {
        return alliesBox;
    }
}
